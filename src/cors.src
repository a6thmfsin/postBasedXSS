<!DOCTYPE html>
<html>
<head>
<style>
	/* Style the button that is used to open and close the collapsible content */
	.collapsible {
	  background-color: #eee;
	  color: #444;
	  cursor: pointer;
	  padding: 18px;
	  width: 100%;
	  border: none;
	  text-align: left;
	  outline: none;
	  font-size: 15px;
	}

	/* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
	.active, .collapsible:hover {
	  background-color: #ccc;
	}

	/* Style the collapsible content. Note: hidden by default */
	.content {
	  padding: 0 18px;
	  display: none;
	  overflow: hidden;
	  background-color: #f1f1f1;
	}

	img {
  		border: 3px solid #555;
	}

</style>
</head>
<body>
	<Title>XSS Lab - CORS</Title>
	<h1>POST Based XSS Lab - CORS</h1>
	<p>Lab to demonstrate using CORS vulnerability to exploit reflected post based XSS.</p>

	<p><a href="/">Home</a></p>

	<button type="button" class="collapsible">Open Tutorial</button>
	<div class="content">
		<p>Unlike the prior two tutorials where a form POST allowed us to send our XSS payload, <br>
		many applications send user inputs to the server in JSON. An HTML form cannot generate JSON<br>
		so form based attacks will not work here. To create valid JSON we need JavaScript. We have<br>
		quite the chicken and egg problem here, we can't inject our malicious JavaScript without JSON<br>
		which we can't generate without... JavaScript.<br><br>
		Enter CORS vulnerabilities.<br><br>
		CORS or Cross-Origin Resource Sharing is a method to selectively reduce application security<br>
		by permitting third-party sites to use JavaScript againt your own application. <br>
		By default browsers will not let JavaScript on one site create requests to another site. <br>
		Some sites set a too lenient CORS policy, or dynamically generate one based on the <b>Origin</b> header.<br><br>
		I like to think of CORS vulnerabilities as "XSS Lite". You can still use malicious JavaScript against<br>
		the application, often retrieving sensitive information, but there are limitations compared to a full<br>
		blown XSS vulnerability. <br><br>
		For example, CORS JavaScript cannot access the application local storage, where API keys might be stored.<br>
		Full XSS would allow for malicious JavaScript that can read local storage of the web application.<br><br>
		If you have a POST based XSS using JSON, and a CORS vulnerability you can use a CORS attack to <br>
		inject your XSS payload. Essentially bootstrapping your XSS with a CORS vulnerability to get<br>
		more powerful malicious JavaScript capabilities.<br>




		The easiest way to craft this attack is again getting our form POST request into Burp.<br>
		<image src="./static/csrfFormPost1.png"><br>
		Right click on the request, select <b>Engagement tools</b> and then <b>Generate CSRF PoC</b><br>
		<image src="./static/csrfPocGeneration1.png"><br>
		<image src="./static/poc1.png"><br>

		Burp suite (pro version at least) will generate a CSRF webpage that will submit the malicious<br>
		XSS payload for you as a POST request.<br>
	</p>
	</div>


	<h2>JSON Based XSS Form:</h2>
	<form>
	  <label for="fname">First name:</label>
	  <input type="text" id="fname" name="fname"><br><br>
	  <label for="lname">Last name:</label>
	  <input type="text" id="lname" name="lname"><br><br>
	  <input type="submit" value="Submit">
	</form>

	<script>
		async function handleSubmit(events)
		{
			event.preventDefault();
			const formData  = new FormData(event.target);
			const firstName = formData.get('fname');
			const lastName  = formData.get('lname');

			console.log("Got form submit: "  + firstName + " " + lastName);

			const object = {fname: firstName, lname: lastName};

			const response = await fetch('/corsPost', {
				method: 'POST',
				body: JSON.stringify(object),
				headers: {
					'Content-Type': 'application/json'
				}
			});

		}

		const form = document.querySelector('form');
		form.addEventListener('submit', handleSubmit);

	</script>


	<!-- Handle nice collapse stuff for tutorial -->
	<script>
	var coll = document.getElementsByClassName("collapsible");
	var i;

	for (i = 0; i < coll.length; i++) {
	  coll[i].addEventListener("click", function() {
	    this.classList.toggle("active");
	    var content = this.nextElementSibling;
	    if (content.style.display === "block") {
	      content.style.display = "none";
	    } else {
	      content.style.display = "block";
	    }
	  });
	}
	</script>

</body>
</html>